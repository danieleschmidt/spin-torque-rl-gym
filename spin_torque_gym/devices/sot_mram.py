"""Spin-Orbit Torque MRAM device implementation.

This module implements a SOT-MRAM device model that inherits from BaseSpintronicDevice.
SOT-MRAM uses spin Hall effect in heavy metals (e.g., Pt, W, Ta) to generate
spin-orbit torques for magnetization switching.
"""

import warnings
from typing import Any, Dict, Optional, Tuple

import numpy as np

from .base_device import BaseSpintronicDevice


class SOTMRAMDevice(BaseSpintronicDevice):
    """Spin-Orbit Torque MRAM device model.
    
    This class implements the physics of SOT-MRAM devices where magnetization
    switching is driven by spin-orbit torques generated by the spin Hall effect
    in adjacent heavy metal layers.
    """

    def __init__(self, device_params: Dict[str, Any]):
        """Initialize SOT-MRAM device.
        
        Args:
            device_params: Dictionary containing device parameters
        """
        super().__init__(device_params)

        # Validate required parameters
        self._validate_sot_params()

        # SOT-specific parameters
        self.spin_hall_angle = device_params.get('spin_hall_angle', 0.1)
        self.heavy_metal_thickness = device_params.get('heavy_metal_thickness', 5e-9)
        self.heavy_metal_resistivity = device_params.get('heavy_metal_resistivity', 2e-7)
        self.interface_transparency = device_params.get('interface_transparency', 0.5)
        self.field_like_efficiency = device_params.get('field_like_efficiency', 0.1)
        self.damping_like_efficiency = device_params.get('damping_like_efficiency', 0.2)

        # Cache commonly used values
        self._update_cached_parameters()

    def _validate_sot_params(self) -> None:
        """Validate SOT-specific parameters."""
        required_params = [
            'volume', 'saturation_magnetization', 'damping',
            'uniaxial_anisotropy', 'easy_axis'
        ]

        for param in required_params:
            if param not in self.device_params:
                raise ValueError(f"Missing required parameter: {param}")

        # Validate parameter ranges
        if self.device_params.get('spin_hall_angle', 0.1) > 1.0:
            warnings.warn("Spin Hall angle > 1.0 is physically unrealistic")

    def _update_cached_parameters(self) -> None:
        """Update cached parameters for efficiency."""
        # Calculate effective spin current density
        self.j_s_efficiency = (
            self.spin_hall_angle *
            self.interface_transparency *
            (self.heavy_metal_thickness / (self.heavy_metal_thickness + self.thickness))
        )

        # Torque efficiency factors
        self.tau_dl_factor = self.damping_like_efficiency * self.j_s_efficiency
        self.tau_fl_factor = self.field_like_efficiency * self.j_s_efficiency

        # Resistance parameters
        self.sheet_resistance_hm = self.heavy_metal_resistivity / self.heavy_metal_thickness
        self.area = self.device_params.get('area', self.volume / self.thickness)

    def compute_effective_field(
        self,
        magnetization: np.ndarray,
        applied_field: np.ndarray
    ) -> np.ndarray:
        """Compute effective magnetic field including all contributions.
        
        Args:
            magnetization: Current magnetization vector (normalized)
            applied_field: Applied external magnetic field (A/m)
            
        Returns:
            Effective magnetic field (A/m)
        """
        # Uniaxial anisotropy field
        easy_axis = self.device_params['easy_axis']
        anisotropy_constant = self.device_params['uniaxial_anisotropy']
        h_anis = (2 * anisotropy_constant / (self.mu0 * self.saturation_magnetization)) * np.dot(magnetization, easy_axis) * easy_axis

        # Exchange field (simplified - assuming uniform magnetization)
        exchange_constant = self.device_params.get('exchange_constant', 0.0)
        h_exchange = np.zeros(3)  # For uniform state

        # Demagnetization field (shape-dependent)
        h_demag = self._compute_demagnetization_field(magnetization)

        # Thermal field (if temperature is specified)
        temperature = self.device_params.get('temperature', 0.0)
        h_thermal = self._compute_thermal_field(temperature) if temperature > 0 else np.zeros(3)

        # Dzyaloshinskii-Moriya interaction field (interface DMI in SOT devices)
        dmi_constant = self.device_params.get('dmi_constant', 0.0)
        h_dmi = self._compute_dmi_field(magnetization, dmi_constant)

        return applied_field + h_anis + h_exchange + h_demag + h_thermal + h_dmi

    def _compute_demagnetization_field(self, magnetization: np.ndarray) -> np.ndarray:
        """Compute demagnetization field based on device geometry."""
        # Simplified demagnetization field for thin film geometry
        # Assumes elliptical cross-section with aspect ratio
        aspect_ratio = self.device_params.get('aspect_ratio', 1.0)

        # Demagnetization factors (approximate for elliptical geometry)
        if aspect_ratio >= 1.0:
            n_x = 1.0 / (1.0 + aspect_ratio)
            n_y = aspect_ratio / (1.0 + aspect_ratio)
        else:
            n_x = aspect_ratio / (1.0 + aspect_ratio)
            n_y = 1.0 / (1.0 + aspect_ratio)
        n_z = 1.0 - n_x - n_y

        n_tensor = np.array([n_x, n_y, n_z])
        h_demag = -self.saturation_magnetization * n_tensor * magnetization

        return h_demag

    def _compute_thermal_field(self, temperature: float) -> np.ndarray:
        """Compute thermal fluctuation field."""
        if temperature <= 0:
            return np.zeros(3)

        # Thermal field magnitude based on fluctuation-dissipation theorem
        kb = 1.38e-23  # Boltzmann constant
        alpha = self.device_params.get('damping', 0.01)
        gamma = 2.21e5  # Gyromagnetic ratio (m/(A⋅s))

        # Thermal field strength
        h_thermal_strength = np.sqrt(
            2 * alpha * kb * temperature /
            (self.mu0 * self.saturation_magnetization * self.volume * gamma)
        )

        # Random field direction (this would be implemented with proper random number generation in practice)
        return h_thermal_strength * np.array([0.0, 0.0, 0.0])  # Simplified - should be random

    def _compute_dmi_field(self, magnetization: np.ndarray, dmi_constant: float) -> np.ndarray:
        """Compute Dzyaloshinskii-Moriya interaction field."""
        if abs(dmi_constant) < 1e-12:
            return np.zeros(3)

        # Interfacial DMI field (simplified for uniform magnetization)
        # In practice, this requires spatial derivatives
        # For now, return zero field for uniform case
        return np.zeros(3)

    def compute_spin_torque(
        self,
        current_density: float,
        magnetization: np.ndarray,
        current_direction: Optional[np.ndarray] = None
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Compute spin-orbit torques on magnetization.
        
        Args:
            current_density: Applied current density (A/m²)
            magnetization: Current magnetization vector (normalized)
            current_direction: Current flow direction (default: [1,0,0])
            
        Returns:
            Tuple of (damping-like torque, field-like torque) vectors
        """
        if current_direction is None:
            current_direction = np.array([1.0, 0.0, 0.0])

        current_direction = current_direction / np.linalg.norm(current_direction)

        # Spin polarization direction from spin Hall effect
        # σ × J where σ is spin direction and J is current direction
        spin_direction = np.cross(np.array([0.0, 0.0, 1.0]), current_direction)  # z × J

        # Damping-like torque: τ_DL = τ_DL_factor * J * (σ × m)
        tau_dl = self.tau_dl_factor * current_density * np.cross(spin_direction, magnetization)

        # Field-like torque: τ_FL = τ_FL_factor * J * σ
        tau_fl = self.tau_fl_factor * current_density * spin_direction

        return tau_dl, tau_fl

    def compute_resistance(self, magnetization: np.ndarray) -> float:
        """Compute device resistance based on magnetization state.
        
        Args:
            magnetization: Current magnetization vector
            
        Returns:
            Device resistance (Ω)
        """
        # For SOT-MRAM, we consider both magnetic tunnel junction resistance
        # and heavy metal layer resistance

        # MTJ resistance (similar to STT-MRAM)
        reference_mag = self.device_params.get('reference_magnetization', np.array([0, 0, 1]))
        reference_mag = reference_mag / np.linalg.norm(reference_mag)

        cos_theta = np.dot(magnetization, reference_mag)

        r_p = self.device_params.get('resistance_parallel', 1e3)
        r_ap = self.device_params.get('resistance_antiparallel', 2e3)

        # TMR effect
        r_mtj = r_p + (r_ap - r_p) * (1 - cos_theta) / 2

        # Heavy metal layer resistance (in parallel with MTJ for SOT geometry)
        r_hm = self.sheet_resistance_hm / (self.area * 1e-12)  # Convert to proper units

        # Total resistance depends on device geometry
        # For SOT devices, current flows through HM layer, voltage measured across MTJ
        # This is a simplified model
        total_resistance = r_mtj + r_hm * 0.1  # Small series resistance from HM

        return max(total_resistance, 1.0)  # Minimum resistance

    def compute_power_consumption(
        self,
        current_density: float,
        pulse_duration: float,
        magnetization: np.ndarray
    ) -> float:
        """Compute power consumption for switching operation.
        
        Args:
            current_density: Applied current density (A/m²)
            pulse_duration: Pulse duration (s)
            magnetization: Current magnetization state
            
        Returns:
            Energy consumed (J)
        """
        if abs(current_density) < 1e-12:
            return 0.0

        # Heavy metal resistance dominates for SOT devices
        current = current_density * self.area
        voltage = current * self.sheet_resistance_hm / (self.area * 1e-12)
        power = voltage * current
        energy = power * pulse_duration

        return energy

    def get_switching_threshold(self) -> Dict[str, float]:
        """Get critical current density for magnetization switching.
        
        Returns:
            Dictionary with threshold parameters
        """
        # Critical current for SOT switching
        # Based on macrospin model for perpendicular magnetization

        easy_axis = self.device_params['easy_axis']
        alpha = self.device_params['damping']

        # Effective anisotropy field
        h_k = 2 * self.device_params['uniaxial_anisotropy'] / (self.mu0 * self.saturation_magnetization)

        # Critical current density for SOT switching
        # Typical values are 10^6 - 10^8 A/m² depending on materials and geometry
        j_c = 5e6 * (1 + alpha) * (1 + h_k / 1e6) / (1 + self.tau_dl_factor)

        return {
            'critical_current_density': j_c,
            'critical_field': h_k,
            'damping_like_efficiency': self.tau_dl_factor,
            'field_like_efficiency': self.tau_fl_factor
        }

    def validate_magnetization(self, magnetization: np.ndarray) -> np.ndarray:
        """Validate and normalize magnetization vector.
        
        Args:
            magnetization: Input magnetization vector
            
        Returns:
            Normalized magnetization vector
            
        Raises:
            ValueError: If magnetization vector is invalid
        """
        if magnetization.shape != (3,):
            raise ValueError("Magnetization must be a 3D vector")

        magnitude = np.linalg.norm(magnetization)
        if magnitude < 1e-12:
            raise ValueError("Magnetization vector cannot have zero magnitude")

        # Normalize to unit vector
        return magnetization / magnitude

    def get_device_info(self) -> Dict[str, Any]:
        """Get comprehensive device information.
        
        Returns:
            Dictionary containing device parameters and computed values
        """
        info = {
            'device_type': 'SOT-MRAM',
            'geometry': {
                'volume': self.volume,
                'thickness': self.thickness,
                'area': self.area,
                'aspect_ratio': self.device_params.get('aspect_ratio', 1.0)
            },
            'magnetic_properties': {
                'saturation_magnetization': self.saturation_magnetization,
                'damping': self.device_params['damping'],
                'uniaxial_anisotropy': self.device_params['uniaxial_anisotropy'],
                'easy_axis': self.device_params['easy_axis'].tolist(),
                'dmi_constant': self.device_params.get('dmi_constant', 0.0)
            },
            'sot_properties': {
                'spin_hall_angle': self.spin_hall_angle,
                'heavy_metal_thickness': self.heavy_metal_thickness,
                'heavy_metal_resistivity': self.heavy_metal_resistivity,
                'interface_transparency': self.interface_transparency,
                'damping_like_efficiency': self.damping_like_efficiency,
                'field_like_efficiency': self.field_like_efficiency
            },
            'electrical_properties': {
                'resistance_parallel': self.device_params.get('resistance_parallel', 1e3),
                'resistance_antiparallel': self.device_params.get('resistance_antiparallel', 2e3),
                'sheet_resistance_hm': self.sheet_resistance_hm
            },
            'computed_values': {
                'j_s_efficiency': self.j_s_efficiency,
                'tau_dl_factor': self.tau_dl_factor,
                'tau_fl_factor': self.tau_fl_factor
            }
        }

        # Add switching threshold information
        info['switching_threshold'] = self.get_switching_threshold()

        return info

    def get_parameter(self, param_name: str, default: Any = None) -> Any:
        """Get device parameter value.
        
        Args:
            param_name: Parameter name
            default: Default value if parameter not found
            
        Returns:
            Parameter value
        """
        return self.device_params.get(param_name, default)

    def update_temperature(self, temperature: float) -> None:
        """Update operating temperature.
        
        Args:
            temperature: New temperature (K)
        """
        self.device_params['temperature'] = temperature

        # Update temperature-dependent parameters
        # (In practice, this would update material properties)
        if temperature > 400:
            warnings.warn(f"High temperature ({temperature} K) may affect device reliability")

    def compute_energy_barrier(self, magnetization: np.ndarray) -> float:
        """Compute energy barrier for magnetization switching.
        
        Args:
            magnetization: Current magnetization state
            
        Returns:
            Energy barrier (J)
        """
        # Energy barrier for uniaxial anisotropy
        easy_axis = self.device_params['easy_axis']
        anisotropy = self.device_params['uniaxial_anisotropy']

        # Angle with easy axis
        cos_theta = abs(np.dot(magnetization, easy_axis))

        # Energy difference between current state and hard axis
        energy_barrier = anisotropy * self.volume * (1 - cos_theta**2)

        return energy_barrier

    def estimate_switching_time(self, current_density: float, temperature: float = 300.0) -> float:
        """Estimate switching time for given current and temperature.
        
        Args:
            current_density: Applied current density (A/m²)
            temperature: Operating temperature (K)
            
        Returns:
            Estimated switching time (s)
        """
        if abs(current_density) < 1e-6:
            return np.inf

        # Get critical current
        j_c = self.get_switching_threshold()['critical_current_density']

        if abs(current_density) < j_c:
            # Thermally activated switching
            kb = 1.38e-23
            energy_barrier = self.device_params['uniaxial_anisotropy'] * self.volume

            # Attempt frequency (typical ~GHz)
            f0 = 1e9

            # Current assistance factor
            assistance_factor = abs(current_density) / j_c

            switching_time = (1 / f0) * np.exp(
                energy_barrier / (kb * temperature) * (1 - assistance_factor)
            )
        else:
            # Deterministic switching
            alpha = self.device_params['damping']
            gamma = 2.21e5  # Gyromagnetic ratio

            # Simplified switching time estimate
            switching_time = (np.pi * alpha) / (gamma * self.tau_dl_factor * abs(current_density))

        return switching_time

    def __repr__(self) -> str:
        """String representation of device."""
        return (f"SOTMRAMDevice(volume={self.volume:.2e} m³, "
                f"Ms={self.saturation_magnetization:.0f} A/m, "
                f"SHA={self.spin_hall_angle:.3f})")
